**进程间同步互斥的方法**

from multiprocessing import Lock
创建进程锁对象
lock = Lock()

1.lock.acquire()  给临界区上锁
2.lock.release()  给临界区解锁
*具体实现上acquire()为一个条件阻塞函数，当有任意一个进程先进行了acquire操作后，其它进程再企图进行acquire操作时就会阻塞，直到lock对象被release后其它进程才可以进行下一次的acquire操作
*所有进程对临界资源都做加锁操作，程序之间才有影响．
3.with lock:  也可以实现加锁/解锁(加锁，语句块结束即自动解锁)

**线程**
*线程也可以使用计算机的多核资源，也是多任务编程方式之一
*线程又称为轻量级的进程，在并发上和进程相同，但是在创建时消耗的资源少
一个进程中可以包含多个线程，这多个线程共享进程的资源
多个线程因为共享进程的资源，所以在线程通信上往往采用全局变量的方法
线程也有自己特有的资源，比如TID，指令集等
(线程是利用内核的最小单位，进程是系统资源占用的最小单位)

多进程和多线程的区别和联系
1.多进程和多线程都是多任务编程方式，都可以使用计算机多核
2.进程的创建要比线程的创建消耗更多的资源
3.进程空间独立，数据更安全，有专门的进程间通信方式进行交互
4.一个进程包含多个线程，所以线程共享进程资源，没有专门的通信方法，依赖全局量进行通信；往往需要使用同步互斥机制，逻辑需要考虑更多
5.进程和线程都有自己独特的资源；多个关联任务的时候使用多线程资源消耗的更少，如果是多个无关任务也不适于全都使用线程

**创建线程**
    threading模块
  创建线程函数
    threading.Thread()
    功能：创建线程
    参数：target  线程函数
    　　　　　args　　　　以元组方式给线程函数传参  
         kwargs  以字典方式给线程函数传参
　        name    线程名称　(默认Thread-1...)
    返回值：返回线程对象
  线程的属性和方法
    t.start():启动一个线程
    t.join([sec]):阻塞等待回收线程
    t.is_alive():查看一个线程的状态
    t.name:查看线程的名称
    daemon属性
      1.t.daemon = True / t.setDaemon(True)
        设置  该属性默认为False，主线程执行完毕后不会影响其它线程的执行；
             如果设置为True，则主线程执行完毕其它线程也终止执行
      2.t.isDaemon():获取daemon属性值

**线程间的通信**
使用全局变量进行通信

**线程 event**
创建事件对象
e = threading.Event()
e.wait([timeout])  如果e被设置则不会阻塞，未被设置则阻塞；timeout为阻塞的超时时间
e.set()  将e变为设置的状态
e.clear()  将e变为未设置的状态

**线程锁**
lock = threading.Lock()  创建锁对象
lock.acquire()  上锁
lock.release()  解锁
with lock       加锁/解锁

**创建自己的线程类**
　　1.自定义类继承于原有的线程类　Thread
　　2.复写原有的run方法
　　3.创建线程对象调用start的时候会自动执行run函数

**线程池**
threadpool(第三方模块)
安装过程：sudo pip3 install threadpool

**GIL(全局解释器锁)**
python ---> 支持多线程 ---> 同步和互斥 ---> 加锁 ---> 超级锁 ---> 解释器在同一时刻只能解释一个线程

大量python库的操作，为了省事依赖于这种机制 ---> python多线程效率低

GIL　即为cpython解释器由于上锁带来的同一时刻只能解释一个线程的问题
解决方案：
    1.不使用线程，转而使用进程
    2.不使用C作为解释器(java, c# 都可以做python解释器)

IO密集型程序 ---> 程序中进行了大量IO操作，只有少量的cpu操作
  在内存中进行了数据的交换的操作都可以认为是IO操作
  特点：速度较慢，使用cpu不高
cpu密集型程序(计算密集型) ---> 大量的程序都在进行运算操作
  特点：cpu占有率高

效率测试
line cpu 2.6798880100250244   单线程
line IO 5.881449222564697

Thread cpu 2.0597434043884277  多线程
Thread IO 5.16146993637085

Process cpu 1.3892300128936768  多进程
Process IO 3.1005592346191406
*多线程的工作效率和单线程功能效率几乎相近，而多进程执行要比前两者有明显的效率提升


**设计模式**
设计模式代表了一种最佳实践，是被开发人员长期开发总结，用来解决某一类问题的思路方法；
这些方法保证了代码的效率也易于理解

23种设计模式(单例模式　　工厂模式　　生产者模式　　...)
高内聚：在同一模块内，实现单一功能，尽量不使功能混杂
低耦合：在不同的模块之间，尽量相互独立，减少模块间的影响

生产者消费者模式
代码的实现　--> producer_consumer.py

面试问题：
1.进程和线程的区别
2.什么是同步和互斥
3.给一个具体的情况，问采用进程还是线程，问什么？
4.你是怎么处理僵尸进程的
5.怎么测试一个硬盘的读写速度？
6.XXX框架　是用的多进程还是多线程
7.进程间通信方式知道哪些？都有什么特点？