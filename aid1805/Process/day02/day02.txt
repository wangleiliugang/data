处理僵尸进程的方法:
    3.创建二级子进程处理
    4.在父进程中使用信号处理的方法忽略子进程发来的信号
      signal(SIGCHLD,SIG_IGN)

更方便高效的进程创建方法(python语言提供的)
multiprocessing模块 (标准库模块)
创建进程的步骤：
    1.将要完成的事件封装成一个个函数
    2.使用multiprocessing提供的接口函数(API)创建进程
    3.使新的进程和指定的函数相关联去完成函数中的工作
    4.对进程进行回收处理

*函数当赋给Process的target变量后，函数内容就是对应进程的进程内容，此时函数才有特殊性
*多个子进程和父进程之间的执行相互不影响

1.创建子进程: 
  Process(target=函数名, name='XX', args=(参数,), kwargs={'键':'值'})
    参数: target    指定要绑定的函数
          name      给创建的进程起一个名字
          args      需要一个元组，给target指定的函数按位置传参
          kwargs    需要一个字典，给target指定的函数按键值传参
    Process()类 ---> p 进程对象
    属性方法：
        进程名称： p.name
        进程PID： p.pid
        进程状态： p.is_alive()
2.启动子进程: start()函数
    *start()时才真正的创建子进程，而不是Process时创建
3.回收子进程: join()函数
    join([timeout])
    *使用for循环回收子进程时：内核会帮助应用层记录子进程的退出情况;
     当使用join函数时内核会及时返回进程状态给应用层进行处理
    timeout:设置最长阻塞时间，如果超过这个时间子进程还没有退出则不再继续等待

p.daemon
    默认值为False，表示主进程运行结束后不会影响子进程的运行，直到子进程运行完进程才会结束
    如果设置为True，主进程运行完毕后所有子进程也不再运行一起退出
    *该属性的设置必须要在start()前
    *该属性的设置并不是将进程设置为linux/unix中的守护进程
    守护进程：权限较高，生命周期长，与前端控制台无关，后台运行;
            一般用作系统进程或者自动化运行进程

多进程编程
优点：可以并行的执行多个任务，提高运行效率
     空间独立，数据安全
     创建方便
缺点：进程的创建和销毁过程需要消耗较多的计算机资源

在需要频繁的创建和删除较多进程的情况下，资源消耗过多，不适宜使用多进程完成任务
进程池技术：
    1.创建进程池，在池内放入合适数量的进程
    2.将事件加入进程池的等待队列
    3.使用进程池内的进程不断的执行等待事件
    4.所有事件处理结束后关闭回收进程池

**Pool:创建进程池**
1.pool = multiprocessing.Pool(processes=N)
  参数：processes 进程池中进程的数量

2.使用进程池：
  1.pool.apply_async(func=函数名, args=(参数,), kwargs={'键':'值'})
    功能：以异步的方式将要执行的事件放入进程池中
    参数：func 要执行的函数
         args 给函数按位置传参
         kwds 给函数按照键值传参
    返回值：返回事件执行后的返回值对象;
          可以通过调用get()函数获取事件函数return的内容
  2.pool.apply(func=函数名, args=(参数,), kwargs={'键':'值'})
    功能：按照顺序添加要执行的事件，执行完一个再添加一个
  3.pool.map(func,可迭代对象)
    功能：类似于内建函数map，将第二个参数的迭代对象中的数据逐个代入第一个函数作为参数；
         同时兼顾了apply_async功能，将函数放入进程池
    　　　　pool.map(fun,test) <---> for i in test:
                            等同      pool.apply_async(fun,(i,))
    返回值：无
  4.pool.close()
    功能：关闭进程池，使其不能再加入新的事件
  5.pool.join()
    功能：阻塞等待进程池将事件都执行结束后回收进程池


**创建自己的进程类**
    1.继承Process类以获取原有的属性
    2.实现自己需要的功能部分
    3.使用自己的类创建进程即可
      在Process类中实现的，重写def run(self):函数
    示例：myClick_process.py

**进程间的通信**
    不同的进程间进行数据的传输
  实现方法:
    1.文件进行进程间通信(和磁盘数据交互慢，数据不安全)
    2.新的进程间通信方式：管道　　消息队列　　共享内存　　信号　　套接字　等等

**获取文件的大小的方法:**
  size = os.path.getsize('fork.py')
  size:表示的是文件内容的字节数。


    

