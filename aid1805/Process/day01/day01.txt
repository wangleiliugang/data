进程 线程 网络　　mongodb

多任务编程:可以有效的利用计算机资源，同时执行多个任务
进程：进程就是程序在计算机中一次执行的过程

进程和程序的区别：
程序是一个静态文件的描述，不占用计算机的系统资源
进程是一个动态的过程，占有CPU内存等资源，有一定的生命周期
* 同一个程序的不同执行过程即为不同的进程

问题1：什么决定了进程的创建？
    1.用户通过应用层程序进行进程的创建申请
    2.调用操作系统接口进行进程创建
    3.操作系统告知系统内核创建新的进程提供给应用层使用

问题2：进程如何让占有CPU
    1.同一个内核同一时刻只能运行一个进程
    2.多个进程对内核资源进行抢占，由操作系统内核进行分配
    3.哪个进程占有计算机内核我们称为该进程占有CPU的时间片

问题3：进程在运行过程中的形态和附带内容
    PCB(进程控制块)：在linux和unix操作系统中，进程创建后会在内存中开辟一块空间存放进程的相关信息，这个空间称之为PCB
    # 相关信息
    PID:在操作系统中进程的唯一标识，是一个大于0的正整数，由系统自动分配
    查看进程信息指令：ps -aux
    虚拟内存：每个进程占有4G内存地址空间，这里的内存指的是虚拟内存．(会和物理内存形成映射关系．)
    进程状态：三态 和　五态
    1.三态：
      就绪态：进程具备运行条件，等待系统分派处理器以便运行
      运行态：进程占有cpu处于运行状态
      等待态：又称为阻塞态或者睡眠态，指进程不具备运行条件，正在等待某些条件的达成
    2.五态：
      新建态：创建一个进程的过程，直接表现为执行某个程序或者在程序中创建新的进程
      终止态：进程执行结束，完成回收的过程
      D：等待态(不可中断，不可被外界信号或事件中断)
      S：等待态(可中断)
      T：等待态(暂停)
      R：运行态
      Z：僵尸态
      +：前台进程
      N：低优先级的进程
      <：高优先级的进程
      l：有进程链接
      s：会话组

进程的优先级
    优先级往往决定了一个进程的执行权限和占有系统资源的优先程度
    top :动态查看系统进程运行情况
    q键　:退出
    shift + < / > : 进行翻页查找
    linux系统中优先级范围：-20~19 (NI代表优先级状态，其中-20优先级最高)
    用户创建进程默认优先级为0
    nice:以指定的优先级运行某个进程
        示例：
        nice -9 ./while.py    以9的优先级运行程序
        sudo nice --9 ./while.py    以-9的优先级运行程序
    renice n PID:修改一个正在运行的进程的优先级
        示例：
        renice 8 6500    将6500号进程优先级修改为8

父子进程
    在系统中除了初始化进程之外每个进程都是由父进程创建的，每个进程有一个唯一的父进程，可能有多个子进程．
    pstree:进程树
    
总结
    1.什么是进程？
    2.进程和程序的区别？
    3.进程的几种状态及相互间的转换
    4.什么是PCB PID cpu时间片

写一个程序，在程序中指定位置调用接口来创建新的进程
实现方法:
通过os.fork() 函数实现

**创建进程函数**
import os模块
1.fork():创建一个新的进程
  参数：无
  返回值：<　0　　表示进程创建失败
        == 0  在子进程中fork的返回值为0
        > 0   在父进程中fork的返回值大于0
  * fork是os模块函数，只能在linux和unix下使用

测试1：父进程中fork之前的内容，子进程同样也会复制
      但是父子进程空间内容的修改不会相互影响

测试2：父子进程在执行上互不影响，理论上不一定谁先执行

tarena@tedu:~/aid1805/Process$ ipython3
In [1]: import time
In [2]: time.ctime()
Out[2]: 'Mon Jan 28 22:18:22 2019'
In [3]: quit

测试3：子进程虽然复制父进程的空间，但是也有自己独特的特性，比如：自己的PID，进程控制块，进程栈等；
      父进程中fork的返回值即为创建的子进程的PID号

进程相关函数
1.os.getpid():获取当前进程的PID号
2.os.getppid():获取当前进程父进程的PID号
3.os._exit(status):结束一个进程
  参数：一个数字表示进程的退出状态;
       status:通常0表示正常退出进程，其它数字表示非正常退出
4.sys.exit([status]):结束一个进程，如果处理了抛出的异常则不结束进程
  参数：一个数字表示进程的退出状态;
       [status]:通常0表示正常退出进程，其它数字表示非正常退出;
                还可以是一个字符串，则在进程退出时会打印这个字符串

僵尸进程:子进程先于父进程退出，父进程没有对子进程的退出做出相应的处理，
        此时子进程就会变为僵尸进程.
    影响:进程退出后，仍有部分信息残留在内存中占用空间，大量的僵尸进程会影响系统运行，
        所以应该尽量避免僵尸进程的产生.
孤儿进程:父进程先于子进程退出，此时子进程就会变为孤儿进程
    影响:当一个进程变为孤儿进程，系统会自动的分配一个进程成为孤儿进程的父进程，
        当孤儿进程退出时，该系统进程会自动回收孤儿，使他不会成为僵尸，
        所以孤儿进程对系统资源没有什么影响

**处理僵尸进程的方法:**
    1.让父进程先退出  (不好控制)
    2.父进程处理子进程的退出  (阻塞父进程的运行)
    3.创建二级子进程处理
    4.在父进程中使用信号处理的方法忽略子进程发来的信号
      signal(SIGCHLD,SIG_IGN)

1.os.wait():等待子进程退出进行处理
  参数:无
  返回值:返回一个包含两个元素的元组，第一个是退出的子进程的PID号，第二个是子进程的退出状态
  *wait 是一个阻塞函数，即进程处于等待态，等待某种条件的达成才会继续运行.

2.os.waitpid(pid, option):同wait()，处理子进程退出使其不会变成僵尸进程
  参数: pid      -1      　   表示等待任意子进程退出
                >0数字       表示等待指定进程号的子进程退出
       option    0          表示阻塞等待
             WNOHANG        表示非阻塞状态
  返回值：同wait

wait() ==>等价于 waitpid(-1, 0)

作业：
    使用open拷贝一个文件，要求将文件拷贝为两份，第一份为前半部分，第二份为后半部分，分别用父子进程拷贝

总结
1.函数的使用　fork getpid getppid os._exit sys.exit wait waitpid
2.理解什么是僵尸进程，什么是孤儿进程，以及两者产生的过程
3.知道僵尸进程的危害和两种处理方法
4.理解进程的创建流程