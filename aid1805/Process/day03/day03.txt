**1.管道**
    在内存中开辟一个管道空间，对多个进程可见；在通信形式上形成一种约束

linux操作系统
  (文件类型：bcd-lsp)
    b:块设备文件(如：驱动)
    c:字符设备文件(如：鼠标，键盘，打印机，显示器)
    d:目录
    -:普通文件
    l:链接
    s:套接字
    p:管道

multiprocessing -----> Pipe函数
Pipe(duplex)
    功能：创建一个管道
    参数：duplex 默认为True，表示管道为全双工(双向管道)；
         如果设置为False 则表示管道为半双工(单向管道).
    返回值：返回两个管道流对象，分别表示管道的两端;
           如果参数为True(默认)，两个对象均可发送接收;
           如果为False，则第一个对象只能接收，第二个对象只能发送.

*向管道发送数据使用send()函数，从管道接收数据使用recv()函数
*recv()函数为阻塞函数，当管道中数据为空的时候会阻塞
*执行一次recv()语句，只能接收一次send()的内容
*send()可以发送字符串，数字，列表等多种类型的数据

**2.消息队列**
    在内存中开辟一个队列模型，用来存放消息；任何拥有队列对象的进程都可以进行消息的存放和取出

multiprocessing -----> Queue函数
q = Queue(maxsize = 0)
    功能：创建一个消息队列对象
    参数：maxsize 默认为0　　　　　表示消息队列可以存放的消息由系统自动分配的空间决定
                 > 0正整数　　　表示队列中最多存放多少条消息
    返回值：消息队列对象

q.put()
    向消息队列中存放一条消息，当消息队列满的时候，会阻塞
    存放的消息类型可以是数字，列表，字符串等数据类型
q.get()
    获取消息，每次获取一条，当消息队列为空时，会阻塞
q.qsize()
　　　　查看当前消息队列中消息的数量
q.full()
    判断队列是否为满，如果满则返回True，否则返回False
q.empty()
    消息队列为空返回True，不为空则返回False
**q.put() / q.get()函数中block参数和timeout参数:**
    block   默认为True 表示两个函数都是阻塞函数；如果设置为False则表示不阻塞
    timeout 当block设置为True的时候表示超时等待时间

**3.共享内存**
    在内存中开辟一段内存空间存储数据，每次存储的内容会覆盖上次的内容；由于没有对内存进行格式化的修饰，所以存取速度快效率高

from multiprocessing import Value,Array函数
obj = Value(ctype,val)
    功能：开辟共享内存
    参数：ctype  要转变的C语言的类型
         val    要写入共享内存的初始值
obj.value属性: 获取共享内存中的值

obj = Array(ctype,val)
    功能：开辟一个共享内存空间
    参数：ctype  要转换的C语言的类型
         val    要写入共享内存中的数据，是一个列表，要求列表中的数据为相同类型的数据；
                如果val传入一个正数，则表示在共享内存中开辟一个多大的空间，空间中可以存放的数值类型由ctype确定
    返回值：返回一个可迭代对象，通过for循环取值，可以进行修改

**4.信号**
1.kill -l  查看系统信号
2.kill -signame PID  给进程号为PID的进程发送signame信号
  示例：
    1.开启一个进程:python3 while.py
    2.kill -9 3796(进程号)

信号：　信号名称　　含义　　默认处理方法
信号名称：系统定义
含义：系统定义
处理方式：采用默认方式处理    系统定义(终止，暂停，忽略)
         忽略信号(当信号未发生过)
         采用自定义的方式处理

**如何发送信号**
1.os.kill(pid,sig):向一个进程发送一个信号
  参数：pid  要发送进程的PID号
       sig  要发送的信号
2.signal.alarm(sec):给自己发送一个时钟信号(SIGALRM)
  参数：sec(秒数)  表示在相应的秒数后发送时钟信号

*信号是一种异步的进程间通信方式.
*alarm函数在一个进程中如果使用多次，则后面的时钟时间会覆盖前面的时间.

**信号的处理**
1.signal.pause():阻塞等待一个信号的发生
2.signal.signal(sig,handler):处理信号
  参数：sig    　 表示可以处理的信号
       handler  信号的处理方法
              1.默认处理方式： SIG_DFL
              2.忽略信号：　　　 SIG_IGN
              3.自定义的方式：　function

*signal函数是一种异步处理信号函数
*SIGSTOP和SIGKILL不能被signal函数处理，只能使用默认方式．

**僵尸进程的信号处理方案(在父进程中写上)**
  signal(SIGCHLD,SIG_IGN)

同步和互斥

临界资源：对多个进程或者线程都可见的资源，容易产生争夺，我们将这类资源称为临界资源
临界区：对临界资源进行操作的代码区域称之为临界区

解决资源争夺方法：同步/互斥
同步：是一种合作关系，为完成某种任务而建立的多个进程或者线程之间的协调调用，次序等待，
     传递消息告知资源占用情况
互斥：是一种制约关系，当一个进程或者线程进入到临界区后会进行加锁操作，
     此时其它进程(线程)无法进入临界区，只有当该进程(线程)使用后进行解锁，其他进程(线程)才可以使用；
     这种技术往往是通过阻塞完成

Event 事件
multiprocessing -----> Event函数

e = Event()  # 生成事件对象
e.wait()  # 提供事件的阻塞，如果事件被设置则不会阻塞。
e.is_set()  # 检测事件对象，如果被设置返回True，否则返回False
e.set()  # 设置事件对象
e.clear()  # 清除对事件的阻塞
详见：process_event.py

练习：
售票员和司机的故事
1.创建父子进程，分别表示司机和销售员
2.当售票员捕捉到SIGINT信号时，给司机发送SIGUSR1信号，司机打印"老司机开车了"
  当售票员捕捉到SIGQUIT信号时，给司机发送SIGUSR2信号，司机打印"系好安全带，小心甩出去"
  当司机捕捉到SIGTSTP信号时，给售票员发送SIGUSR1信号，售票员打印"到站了，下车吧"
3.到站后，售票员先下车(子进程先退出)，然后司机下车
详见：exercise_driver.py



