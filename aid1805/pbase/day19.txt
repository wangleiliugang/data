用于类的函数
　　issubclass(cls, class_or_tuple) 判断一个类是否继承自其它的类，如果此类cls是class或
                                  tuple中的一个派生子类则返回True,否则返回False
  示例： class A
            pass
        class B(A):
            pass
        class C(B):
            pass
        issubclass(C, (A, B))  # True
        issubclass(C, (int, str))  # False

查看python 内建类的继承关系的方法：>>>help(__builtins__)

封装　enclosure
  封装是指隐藏类的实际细节，让使用者不用关心这些细节
  封装的目的是让使用者用尽可能少的实例变量(属性)进行操作

私有属性：
　　python 类中，以双下划线'__'开头，不以双下划线结尾的标识符为私有成员，在类的外部无法直接访问
示例见：92_enclosure.py

多态 polymorphic
  字面意思："多种状态"
  多态是指在继承/派生关系的类中，调用基类对象的方法，实际能调用子类的覆盖版本方法的现象

说明：多态调用的方法与对象相关，不与类型相关
　　　　　python 的全部对象都只有"运行时状态(动态)"，没有"C++/Java"里的"编译时状态(静态)"
示例见：93_polymorphic.py

面向对象的编程语言的特征：
  1.继承
  2.封装
  3.多态
　　编程语言如：
　　    C++ / Java / Python / Swift / C#

多继承　multiple inheritance
  多继承是指一个子类继承自两个或两个以上的基类
  语法：class 类名(基类名1, 基类名2, ...)
           语句块
　　说明：1.一个子类同时继承子多个父类，父类中的方法可以同时被继承下来
　　　　　　　2.如果两个父类中有同名的方法而在子类中又没有覆盖此方法时，调用结果难以确定
  示例见:94_multiple_inheritance.py

多继承的问题(缺陷)
　　标识符(名字空间冲突的问题)
　　　　要谨慎使用多继承
　　示例见:94_multiple_inheritance_bug.py
  python3 中采用广度优先原则(c3算法)

继承的MRO(Method Resolution Order)问题
  类内的__mro__属性用来记录继承方法的查找顺序
　　示例见:95_mro.py
　　      95_mro2.py

函数重写　override
  重写是在自定义的类内添加相应的方法，让自定义的类生成的对象(实例)像内建对象一样进行内建的函数操作

对象转字符串函数重写
　　repr(obj) 返回一个能代表此对象的表达式字符串，通常：eval(repr(obj)) == obj
  str(obj)  通常给定的对象返回一个字符串(这个字符串通常是给人看的)
　　>>> s = "hello world!"
      s1 = repr(s)
      s2 = str(s)
      print(s1)  # "hello world!"(表达式字符串，可以用eval函数执行)
      print(s2)  # hello world!(字符串，不可以用eval函数执行)
示例见:97_str_repr.py

对象转字符串函数重写方法：
　　repr()　函数的重写方法：
　　　　def __repr__(self):
        return 能够表达self 内容的字符串
　　str()　函数的重写方法：
　　　　def __str__(self):
        return 人能够看懂的字符串
　　说明：1.str(obj) 函数优先调用obj.__str__()方法返回字符串
　　　　　　　2.如果obj没有__str__()方法，则调用obj.__repr__()方法返回的字符串
　　　　　　　3.如果obj没有__repr__()方法，则调用object类的__repr__()　实例方法
         显示<xxxx>格式的字符串

数值转换函数的重写:
　　def __complex__(self)    complex(obj)　函数调用
　　def __int__(self)        int(obj)　函数调用
　　def __float__(self)      float(obj)　函数调用
　　def __bool__(self)       bool(obj)　函数调用
示例见：97_str_repr.py

内建函数的重写:
　　__abs__           abs(obj)
　　__len__           len(obj)
　　__reversed__      reversed(obj)
　　__round__         round(obj)

布尔测试函数的重写:
　　格式: def __bool__(self):
           ...
  作用：用于bool(obj)函数取值
  　　　　　用于if 语句真值表达式中
  　　　　　用于while 语句真值表达式中
  说明：1.优先调用__bool__方法取值
  　　　　　2.如果不存在__bool__方法，则用__len__()方法取值后判断是否为零值，如果不为零返回True，否则返回False
       3.如果再没有__len__方法，则直接返回True

迭代器(高级)
　　什么是迭代器？
    可以通过next(it) 函数取值的对象就是迭代器
　　迭代器协议：
　　　　迭代器协议是指对象能够使用next函数获取下一项数据，在没有下一项数据时触发一个StopIterator来终止迭代的约定
　　实现方法：
　　　　类内需要有__next__(self) 方法来实现迭代器协议
　　语法形式：
　　　　class MyIterator:
        def __next__(self):
            迭代器协议的实现
            return 数据
  什么是可迭代对象？
  　　是指能用iter(obj) 函数返回迭代器的对象(实例)
  　　可迭代对象内部一定要定义__iter__(self)方法来返回迭代器
  可迭代对象的语法形式：
  　　class MyIterator:
        def __iter__(self):
            语句块
            return 迭代器
  示例见：100_myiterator.py
