课程内容:
1. 网络编程
2. 进程线程
3. 正则表达式
4. MongoDB数据库
5. git使用
6. 基础项目

OSI:网络信息传输比较复杂需要很多功能协同-->将功能分开，降低耦合度，让每个模块完成一定的功能-->
    将这些模块按照一定的顺序进行组合，完成功能，调理清晰。
    按照规定功能，顺序排列的体系结构:OSI模型。
一. 网络编程
  1. 网络功能 ：数据的传输
  2. OSI七层模型
         制定组织： ISO（国际标准化组织）
     作用：使网络通信工作流程标准化
         应用层 ： 提供用户服务，具体功能由应用程序实现
         表示层 ： 数据的压缩优化加密
         会话层 ： 建立用户级的连接，选择适当的传输服务
         传输层 ： 建立网络连接，提供合适的连接传输服务 
         网络层 ： 路由选择，网络互联 
         链路层 ： 进行数据交换，控制具体数据的发送
         物理层 ： 提供数据传输的硬件保证，网卡接口，传输介质
         优点 ：1. 建立了统一的工作流程
                2. 分部清晰，各司其职，每个步骤分工明确
                        3. 降低了各个模块之间的耦合度，便于开发
         cookie ： 高内聚  模块功能尽可能单一，不相互掺杂  
                   低耦合  模块之间的关联影响尽可能少
     四层模型（TCP/IP模型）
         背景 ： 实际工作中工程师无法完全按照七层模型要求操作，逐渐演化为更符合实际情况的四层
         应用层 ： 集中了应用，表示，会话的功能
         传输层
         网络层
         物理链路层 ： 链路层依托于硬件设备
  3. 数据传输过程
       【1】 发送端由应用程序发送消息，逐层添加首部信息，最终在物理层发送消息包。
        【2】 发送的消息经过多个节点（交换机，路由器）传输，最终到达目标主机。
        【3】 目标主机由物理层逐层解析首部消息包，最终到应用程序呈现消息。
  4. 网络协议
         定义： 在网络数据传输中，都遵循的规定，包括建立什么样的数据结构，什么样的特殊标志等
     应用层协议：TFTP DNS FTP SMTP HTTP
     传输层协议：TCP UDP
     网络层协议：IP ARP ICMP
     物理链路层协议：IEEE
  5. 网络概念
      【1】 网络主机（host） 
           功能：标识一台主机在网络中的位置（地址）
             本地地址 ： 'localhost'
                         '127.0.0.1'  
             网络地址 ： '172.40.91.185'
             * 查看本机网络地址命令： ifconfig
             自动获取地址： '0.0.0.0'
             import socket
             socket.gethostname():获取主机名称
             socket.gethostbyname('localhost'):解析本机IP地址
    【2】 IP地址
            功能：确定一台主机的网络路由位置
                结构：IPv4  点分十进制表示 172.40.91.185 每部分取值范围0--255
                      IPv6  128位 扩大了地址范围             
                特殊IP： 127.0.0.1   本机测试IP
                         0.0.0.0     自动获取本机网卡地址
                                 192.168.1.0  通常表示一个网段
                                 192.168.1.1  通常表示一个网关
                                 192.168.1.255  用作广播地址  
            IP地址转换为二进制：
              1.inet_aton：将地址十进制转换为二进制
                socket.inet_aton('192.168.1.2')--> b'\xc0\xa8\x01\x02'
              2.inet_ntoa：将地址二进制转换为十进制 
                socket.inet_ntoa(b'\xc0\xa8\x01\x02')--> '192.168.1.2'
              3.inet_pton(socket.AF_INET,'192.168.1.2')
              4.inet_ntop(socket.AF_INET,b'\xc0\xa8\x01\x02')
    【3】 域名
             定义： 给网络服务器地址起的名字
                 作用： 方便记忆，表达一定的含义
                 * ping [ip] : 测试和某个主机是否联通      
    【4】 端口号（port）
            作用：端口是网络地址的一部分，用于区分主机上不同的网络应用程序。
                特点：一个系统中的应用监听端口不能重复
                取值范围：1 -- 65535                         
                        1--1023  系统应用或者大众程序监听端口
                        1024--65535 自用端口
      **通过socket.getservbyname('mysql')可以获取各个应用的端口号**
        mysql:3306
        ssh:22
        http:80
        https:443
        telnet:23
        redis:6379

二. 传输层服务
    面向连接的传输服务（基于TCP协议的数据传输）
        1. 传输特征 ： 提供了可靠的数据传输，可靠性指数据传输过程中无丢失，无失序，无差错，无重复。    
        2. 实现手段 ： 在通信前需要建立数据连接，通信结束要正常断开连接。
            【1】 三次握手（建立连接）
                    1. 客户端向服务器发送消息报文请求连接
                    2. 服务器收到请求后，回复报文确定可以连接
                    3. 客户端收到回复，发送最终报文连接建立            
            【2】 四次挥手（断开连接）
                    1. 主动方发送报文请求断开连接
                    2. 被动方收到请求后，立即回复，表示准备断开
                    3. 被动方准备就绪，再次发送报文表示可以断开
                    4. 主动方收到确定，发送最终报文完成断开
        3. 适用情况 ： 对数据传输准确性有明确要求，传数文件较大，需要确保可靠性的情况。
                     比如：网页获取，文件下载，邮件收发。
    面向无连接的传输服务（基于UDP协议的数据传输）
        1. 传输特点 ： 不保证传输的可靠性，传输过程没有连接和断开，数据收发自由随意。
        2. 适用情况 ： 网络较差，对传输可靠性要求不高。比如：网络视频，群聊，广播

面试要求:1. OSI七层模型介绍一下，tcp/ip模型是什么
        2. tcp服务和udp服务有什么区别
        3. 三次握手和四次挥手指什么，过程是怎样的

三. socket套接字编程
    1. 套接字 ：实现网络编程进行数据传输的一种技术手段
    2. Python实现套接字编程   
        import socket
    3. 套接字分类
         流式套接字(SOCK_STREAM): 以字节流方式传输数据，实现tcp网络传输方案。
         数据报套接字(SOCK_DGRAM):以数据报形式传输数据，实现udp网络传输方案。
         面向连接--tcp协议--可靠的--流式套接字
         无连接--udp协议--不可靠--数据报套接字
    **tcp套接字编程**
      【1】服务端流程
         1. 创建套接字
            sockfd=socket.socket(socket_family=AF_INET,socket_type=SOCK_STREAM,
            proto=0)
            功能： 创建套接字
            参数： socket_family  网络地址类型 AF_INET-->ipv4
                  socket_type  套接字类型 SOCK_STREAM 流式
                                        SOCK_DGRAM 数据报
                  proto  通常为0  选择子协议
            返回值： 套接字对象
          2. 绑定地址
            sockfd.bind(addr)
            功能： 绑定本机网络地址
            参数： 二元元组 (ip,port)  ('0.0.0.0',8888)
          3. 设置监听
            sockfd.listen(n)
            功能 ： 将套接字设置为监听套接字，确定监听队列大小
            参数 ： 监听队列大小
          4. 等待处理客户端连接请求
            connfd,addr = sockfd.accept()
            功能： 阻塞等待处理客户端请求
            返回值： connfd  客户端连接套接字
                    addr  连接的客户端地址
            * 阻塞函数 ： 程序运行过程中遇到阻塞函数则暂停执行，直到达成某种条件后继续运行。
          5. 消息收发
            1.data = connfd.recv(buffersize)
              功能 : 接受客户端消息
              参数 ：每次最多接收消息的大小buffersize
              返回值： 接收到的内容
            **当接受的网络缓冲中没有内容时会阻塞
            **当连接断开后，recv会结束阻塞返回一个空字串
            2.n = connfd.send(data)
              功能 : 发送消息
              参数 ：要发送的内容 bytes格式
              返回值：实际发送的字节数
            **  str --> bytes   string.encode("utf-8")
                bytes --> str   bytes.decode("utf-8")
            **connfd.sendall(date)**
              功能：发送网络消息
              参数：要发送的内容，要求为bytes格式
              返回值：如果成功发送返回None，发送失败报异常
          6. 关闭套接字
            sockfd.close()
            功能：关闭套接字
    【2】 客户端流程
            1. 创建套接字
              connfd = socket(AF_INET, SOCK_STREAM)
               * 只有相同类型的套接字才能进行通信
            2. 请求连接
              sockfd.connect(server_addr)
                功能：连接服务器
                参数：元组，服务器地址
            3. 收发消息
              connfd.send(b"hello world!")
              data = connfd.recv(1024)
               * 防止两端都阻塞，recv send要配合
            4. 关闭套接字
              connfd.close()
**TCP循环服务器不能满足多个客户端同时发送请求的情况，它不允许某个客户端单独长期占用服务器资源。**

作业： 1. 要求的3个问题 总结口述
      2. 将tcp程序改写为可以循环的发送接收
         客户端退出后，服务端不退出可以继续处理下一个客户端连接
      3. 复习open文件处理

一. tcp 套接字数据传输特点
    * tcp连接中当一端退出，另一端如果阻塞在recv，此时recv会立即返回一个空字串。
    * tcp连接中如果一端已经不存在，如果试图通过send发送则会产生BrokenPipeError
    * 一个监听套接字可以同时连接多个客户端，也能够重复被连接
    * 网络收发缓冲区
        【1】网络缓冲区有效的协调了消息的收发速度
        【2】send和recv实际是向缓冲区发送接收消息，当缓冲区不为空recv就不会阻塞。
    * tcp粘包
        原因：tcp以字节流方式传输，没有消息边界。多次发送的消息被一次接收，此时就会形成粘包。
        影响：如果每次发送内容是一个独立的含义，需要接收端独立解析此时粘包会有影响。
        处理：1.将消息格式化
             2.发送消息的同时发送一个消息长度标识
             3.控制发送速度
        